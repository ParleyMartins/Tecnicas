/**
Cliente
Class sets exceptions of Cliente.
https://github.com/ParleyMartins/Tecnicas/tree/master/src/model/Cliente.java.
*/

package model;

import exception.ClienteException;


/*Para fazer uma melhor validacoa e captura do dados
 * se pega todos os dados como string.
 */

 abstract class Cliente {
	private String nome;
	private String cpf;
	private String telefone;
	private String email;
	protected String matricula;
	
	//Mensagens de Erro e Alertas
		private final String NOME_INVALIDO = "Nome Invalido.";
		private final String NOME_BRANCO = "Nome em Branco.";
		private final String NOME_NULO = "Nome esta Nulo.";
		private final String CPF_INVALIDO = "CPF Invalido.";
		private final String CPF_BRANCO = "CPF em Branco.";
		private final String CPF_NULO = "CPF esta Nulo.";
		private final String TELEFONE_INVALIDO = "Telefone Invalido.";
		//private final String TELEFONE_BRANCO = "Telefone em Branco.";
		private final String TELEFONE_NULO = "Telefone esta Nulo.";
		//private final String EMAIL_INVALIDO = "E-mail Invalido.";
		//private final String EMAIL_BRANCO = "E-mail em Branco.";
		private final String EMAIL_NULO = "E-mail esta Nulo.";
	
	
 Cliente(String nome, String cpf, String matricula,
		String telefone, String email) throws ClienteException
	// This represents the new client name. A better name could be: Name.
	nome 


	// This represents the new client cpf. A better name could be: clientCpf.
	cpf				


	/*
	This represents the new client enrollment number. A better name could be: 
	enrollmentNumber.
	*/
	matricula

	/*
	This represents the new client phone number. A better name could be:
	phoneNumber.
	*/ 
	telefone

	/*
	This one represents the client new e-mail address. A better name could be:
	 emailAddress.
	*/
	email

// Getters.

 String getNome

 String getCpf

 String getTelefone

 String getEmail

 String getMatricula
	

/*
This methods resets the name and validates it with a regex. If the parameter
doesn't fill the rules, is empty or null an exception is thrown.
*/
 void setNome(String nome) throws ClienteException
	nome 	// It represents the new client name.


/*
This methods resets the cpf and validates it with a regex and a private method.
If the parameter doesn't fill the rules an exception is thrown.
*/
 void setCpf(String cpf) throws ClienteException 
	cpf 	// It represents the new client cpf.


/*
This methods resets the phone number, and validates it with a regex (numbers separated
by hyphens or only numbers). If the parameter doesn't fill the rules, is empty 
or null an exception is thrown.
*/
 void setTelefone(String telefone) throws ClienteException 
 	telefone // It represents the new client phone number.


/*
This methods resets the e-mail, and checks if it's not null. If it is an exception
is thrown. We could validate it with a regex to garantee the regex 'somename@someplace.com'
*/
 void setEmail(String email) throws ClienteException {
 	email //This represents the new client email address.

/*
Since the teachers and students enrollment numbers are different, we wanted to use 
different methods of validation.
*/
abstract void setMatricula(String matricula) throws ClienteException;

@Override
 String toString() {
	return "Nome: " + nome + 
		"\nCpf: " + cpf + 
		"\nTelefone: " + telefone + 
		"\nEmail: " + email + 
		"\nMatricula: " + matricula;
}

 boolean equals(Cliente b){
	if(	this.getNome().equals(b.getNome()) &&
		this.getCpf().equals(b.getCpf()) &&
		this.getMatricula().equals(b.getMatricula()) &&
		this.getTelefone().equals(b.getTelefone()) &&
		this.getEmail().equals(b.getEmail())){
		
		return true;
	}
	return false;
}
	
	private boolean validarCpf(String cpf) {

		int d1, d2;
		int digito1, digito2, resto;
		int digitoCPF;
		String	nDigResult;

		d1 = d2 = 0;
		digito1 = digito2 = resto = 0;

		for (int nCount = 1; nCount < cpf.length() -1; nCount++)
		{
			 digitoCPF = Integer.valueOf (cpf.substring(nCount -1, nCount)).intValue();

			 //multiplique a ultima casa por 2 a seguinte por 3 a seguinte por 4 e assim por diante.
			 d1 = d1 + ( 11 - nCount ) * digitoCPF;

			 //para o segundo digito repita o procedimento incluindo o primeiro digito calculado no passo anterior.
			 d2 = d2 + ( 12 - nCount ) * digitoCPF;
		};

		//Primeiro resto da divisão por 11.
		resto = (d1 % 11);

		//Se o resultado for 0 ou 1 o digito é 0 caso contrário o digito é 11 menos o resultado anterior.
		if (resto < 2)
			 digito1 = 0;
		else
			 digito1 = 11 - resto;

		d2 += 2 * digito1;

		//Segundo resto da divisão por 11.
		resto = (d2 % 11);

		//Se o resultado for 0 ou 1 o digito é 0 caso contrário o digito é 11 menos o resultado anterior.
		if (resto < 2)
			 digito2 = 0;
		else
			 digito2 = 11 - resto;

		//Digito verificador do CPF que está sendo validado.
		String nDigVerific = cpf.substring (cpf.length()-2, cpf.length());

		//Concatenando o primeiro resto com o segundo.
		nDigResult = String.valueOf(digito1) + String.valueOf(digito2);

		//comparar o digito verificador do cpf com o primeiro resto + o segundo resto.
		return nDigVerific.equals(nDigResult);

	} // fim do método validarCpf

}
